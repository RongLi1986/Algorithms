# 复杂度分析
数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。

## 大 O 复杂度表示法
不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法

所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。

T(n) = O(f(n))

T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势

## 时间复杂度分析
1. 只关注循环执行次数最多的一段代码
在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

O(m+n): 复杂度由两个数据的规模来决定
```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```
m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)


3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)*T2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
落实到具体的代码上，我们可以把乘法法则看成是嵌套循环

## 几种常见时间复杂度实例分析
- 多项式量级
1. 常量阶 O(1)
一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)
```java
 int i = 8;
 int j = 6;
 int sum = i + j;
```

2. 对数阶 O(logn)
```java
int i = 1;
while (i <= n)  {
    i = i * 2;
}
```

3. 线性阶 O(n)
```java
int i = 1;
while (i <= n)  {
    i++;
}
```

4. 线性对数阶

5. 多次方阶

- 非多项式量级 NP（Non-Deterministic Polynomial 非确定多项式）
1. 指数阶
2. 阶乘阶

## 空间复杂度分析
空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。

我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到.

## 最好、最坏、平均、均摊
最好情况时间复杂度（best case time complexity)
最坏情况时间复杂度（worst case time complexity)

```java
// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```

## 平均情况时间复杂度
平均情况时间复杂度（average case time complexity)

## 均摊时间复杂度 
均摊时间复杂度（amortized time complexity)